\documentclass[10pt,a4paper,english]{article}

% now ignored, I think:
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Asymptotic Distribution of the Markowitz Portfolio}
%\VignetteKeyword{Finance}
%\VignetteKeyword{Markowitz}
%\VignettePackage{MarkowitzR}

% front matter%FOLDUP
\usepackage[hyphens]{url}
\usepackage{amsmath}
\usepackage{amsfonts}
% for therefore
\usepackage{amssymb}
% for theorems?
\usepackage{amsthm}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{example}{Example}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{caution}{Caution}
\newtheorem*{note}{Note}

% see http://tex.stackexchange.com/a/3034/2530
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{hyperref}
\usepackage[square,numbers]{natbib}
%\usepackage[authoryear]{natbib}
%\usepackage[iso]{datetime}
%\usepackage{datetime}
%\usepackage{gitinfo2}
% make that static for arxiv
<<'githash',cache=FALSE,include=FALSE,echo=FALSE,results='hide'>>=
# https://stackoverflow.com/a/46377001/164611
gitsha <- system("git rev-parse HEAD", intern=TRUE)
@
\providecommand{\gitHash}{\Sexpr{gitsha}}

%%http://choorucode.com/2010/05/05/how-to-add-draft-watermark-in-latex/
%\usepackage{draftwatermark}
%% V1 sent to Mortada.
%% V2 on paper to JHZD.
%% V3 sent to s.lee@BR 140826
%\providecommand{\versnum}{V4}
%\SetWatermarkText{DRAFT \versnum}
%\SetWatermarkLightness{0.87}
%\SetWatermarkScale{4.5}

%\usepackage{fancyhdr}
%\pagestyle{fancy}
%\chead{}
%\rhead{}
%\lhead{}
%\rhead{\sc draft \versnum; do not distribute}
%\rfoot{}

%compactitem and such:
\usepackage[newitem,newenum,increaseonly]{paralist}

\makeatletter
\makeatother

%\input{sr_defs.tex}
\usepackage[notheorems]{SharpeR}

\providecommand{\sideWarning}[1][0.5]{\marginpar{\hfill\includegraphics[width=#1\marginparwidth]{warning}}}

% knitr setup%FOLDUP

<<'preamble', include=FALSE, warning=FALSE, message=FALSE>>=
library(knitr)

# set the knitr options ... for everyone!
# if you unset this, then vignette build bonks. oh, joy.
#opts_knit$set(progress=TRUE)
opts_knit$set(eval.after='fig.cap')
# for a package vignette, you do want to echo.
 opts_chunk$set(echo=FALSE,warning=FALSE,message=FALSE)
#opts_chunk$set(results="asis")
opts_chunk$set(results="hide")
opts_chunk$set(cache=TRUE,cache.path="cache/snrinf")
# for large cache
opts_chunk$set(cache.lazy=FALSE)

#opts_chunk$set(fig.path="figure/",dev=c("pdf","cairo_ps"))
opts_chunk$set(fig.path="figure/snrinf",dev=c("pdf"))
#opts_chunk$set(fig.width=5,fig.height=4,dpi=64)

# common options for figure setup across .Rnw files
IS_BOOK <- FALSE

# for online you want this at 10.0 or so
# for the book, maybe 7.0?
resol <- ifelse(IS_BOOK,7.0,10.0)  # resolution, kindof
aspr  <- 1.41  # aspect ratio
opts_chunk$set(fig.width=resol,
							 fig.height=resol / aspr,
							 out.width="0.975\\textwidth",
							 out.height=sprintf('%.3f\\textwidth',0.975/aspr),
							 dpi=450)

# a more compact figure use 
# fig.width=cfg_width,fig.height=cfg_height,out.width=cot_width,out.height=cot_height,
cfg_width <- resol
cfg_height <- resol / 2
cot_width <- "0.975\\textwidth"
cot_height <- "0.4875\\textwidth"

# a wide figure use
# fig.width=wfg_width,fig.height=wfg_height,out.width=wot_width,out.height=wot_height,
wfg_width <- 1.2 * resol
wfg_height <- 0.6 * resol
if (IS_BOOK) {
	wot_width <- "1.08\\textwidth"
	wot_height <- "0.54\\textwidth"
} else {
	# for e-distribution this is fine, but for book, no
	wot_width <- "1.17\\textwidth"
	wot_height <- "0.585\\textwidth"
}

opts_chunk$set(fig.pos='h')


# doing this means that png files are made of figures;
# the savings is small, and it looks like shit:
#opts_chunk$set(fig.path="figure/",dev=c("png","pdf","cairo_ps"))
#opts_chunk$set(fig.width=4,fig.height=4)
# for figures? this is sweave-specific?
#opts_knit$set(eps=TRUE)

# this would be for figures:
#opts_chunk$set(out.width='.8\\textwidth')
# for text wrapping:
options(width=64,digits=3)
opts_chunk$set(size="small")
opts_chunk$set(tidy=TRUE,tidy.opts=list(width.cutoff=50,keep.blank.line=TRUE))
@
%UNFOLD

<<'setup'>>=
prty <- function(x,...) { prettyNum(x,big.mark=',',...) }
# easier to define this.
finish_plot <- function(x) { x }
@
    
% SYMPY preamble%FOLDUP
    
    %\usepackage{graphicx} % Used to insert images
    %\usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{color} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    %\usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    %\usepackage[utf8]{inputenc} % Allow utf-8 characters in the tex document
    %\usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
		\usepackage{fancyvrb} % verbatim replacement that allows latex
    %\usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    %\usepackage{longtable} % longtable support required by pandoc >1.10
    

    
    
    \definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
    \definecolor{darkorange}{rgb}{.71,0.21,0.01}
    \definecolor{darkgreen}{rgb}{.12,.54,.11}
    \definecolor{myteal}{rgb}{.26, .44, .56}
    \definecolor{gray}{gray}{0.45}
    \definecolor{lightgray}{gray}{.95}
    \definecolor{mediumgray}{gray}{.8}
    \definecolor{inputbackground}{rgb}{.95, .95, .85}
    \definecolor{outputbackground}{rgb}{.95, .95, .95}
    \definecolor{traceback}{rgb}{1, .95, .95}
    % ansi colors
    \definecolor{red}{rgb}{.6,0,0}
    \definecolor{green}{rgb}{0,.65,0}
    \definecolor{brown}{rgb}{0.6,0.6,0}
    \definecolor{blue}{rgb}{0,.145,.698}
    \definecolor{purple}{rgb}{.698,.145,.698}
    \definecolor{cyan}{rgb}{0,.698,.698}
    \definecolor{lightgray}{gray}{0.5}
    
    % bright ansi colors
    \definecolor{darkgray}{gray}{0.25}
    \definecolor{lightred}{rgb}{1.0,0.39,0.28}
    \definecolor{lightgreen}{rgb}{0.48,0.99,0.0}
    \definecolor{lightblue}{rgb}{0.53,0.81,0.92}
    \definecolor{lightpurple}{rgb}{0.87,0.63,0.87}
    \definecolor{lightcyan}{rgb}{0.5,1.0,0.83}
    
    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    
    %\DefineShortVerb[commandchars=\\\{\}]{\|}
    %\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    %% Add ',fontsize=\small' for more characters per line
    %\newenvironment{Shaded}{}{}
    %\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    %\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    %\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    %\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    %\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    %\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    %\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    %\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    %\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    %\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    %\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    %\newcommand{\RegionMarkerTok}[1]{{#1}}
    %\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    %\newcommand{\NormalTok}[1]{{#1}}
    
    %% Define a nice break command that doesn't care if a line doesn't already
    %% exist.
    %\def\br{\hspace*{\fill} \\* }
    %% Math Jax compatability definitions
    %\def\gt{>}
    %\def\lt{<}
    

    %% Pygments definitions
    
%\makeatletter
%\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    %\let\PY@ul=\relax \let\PY@tc=\relax%
    %\let\PY@bc=\relax \let\PY@ff=\relax}
%\def\PY@tok#1{\csname PY@tok@#1\endcsname}
%\def\PY@toks#1+{\ifx\relax#1\empty\else%
    %\PY@tok{#1}\expandafter\PY@toks\fi}
%\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    %\PY@it{\PY@bf{\PY@ff{#1}}}}}}}
%\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

%\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
%\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
%\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
%\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
%\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
%\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
%\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
%\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
%\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
%\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
%\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
%\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
%\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
%\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
%\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
%\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
%\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
%\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
%\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
%\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
%\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
%\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
%\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
%\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
%\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
%\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
%\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
%\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
%\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
%\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
%\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
%\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
%\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
%\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
%\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
%\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
%\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
%\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
%\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
%\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
%\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
%\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
%\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
%\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
%\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
%\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
%\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
%\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
%\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
%\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
%\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

%\def\PYZbs{\char`\\}
%\def\PYZus{\char`\_}
%\def\PYZob{\char`\{}
%\def\PYZcb{\char`\}}
%\def\PYZca{\char`\^}
%\def\PYZam{\char`\&}
%\def\PYZlt{\char`\<}
%\def\PYZgt{\char`\>}
%\def\PYZsh{\char`\#}
%\def\PYZpc{\char`\%}
%\def\PYZdl{\char`\$}
%\def\PYZhy{\char`\-}
%\def\PYZsq{\char`\'}
%\def\PYZdq{\char`\"}
%\def\PYZti{\char`\~}
%% for compatibility with earlier versions
%\def\PYZat{@}
%\def\PYZlb{[}
%\def\PYZrb{]}
%\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=blue,
      linkcolor=darkorange,
      citecolor=darkgreen,
      }
    % Slightly bigger margins than the latex defaults
    
    %\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    %UNFOLD
%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% commands specific to this paper:%FOLDUP
\providecommand{\cono}[1][\typeI]{\mathSUB{c}{#1}}
\providecommand{\pqlUL}[3]{\funcitUL{q}{#1}{#2}{#3}}
\providecommand{\pql}[1]{\pqlUL{}{}{#1}}
%\providecommand{\pqlsq}[1]{\pqlUL{2}{}{#1}}
\providecommand{\dftwo}{\ssiz-\nstrat}

%\providecommand{\pQlUL}[3]{\funcitUL{Q}{#1}{#2}{#3}}
%\providecommand{\pQl}[1]{\pQlUL{}{}{#1}}
%\providecommand{\pQlsq}[1]{\pQlUL{2}{}{#1}}

%\providecommand{\qlev}[1][{}]{\MATHIT{s}}
%\providecommand{\qtl}[1]{\mathUL{q}{}{#1}}
%\providecommand{\qbnd}[1][{}]{\mathUL{B}{}{#1}}

%\providecommand{\prvcsym}{c}
%\providecommand{\cfncUL}[3]{\funcitUL{\prvcsym}{#1}{#2}{#3}}
%\providecommand{\cfnc}[2][{\ssiz}]{\cfncUL{}{#1}{#2}}
%\providecommand{\csqfnc}[2][{\ssiz}]{\cfncUL{2}{#1}{#2}}
%\providecommand{\cfncp}[2][{\ssiz}]{\cfncUL{\prime}{#1}{#2}}

%\providecommand{\prvssym}{s}
%\providecommand{\sfncUL}[3]{\funcitUL{\prvssym}{#1}{#2}{#3}}
%\providecommand{\sfnc}[2][{\ssiz}]{\sfncUL{}{#1}{#2}}
%\providecommand{\csqfnc}[2][{\ssiz}]{\sfncUL{2}{#1}{#2}}
%\providecommand{\sfncp}[2][{\ssiz}]{\sfncUL{\prime}{#1}{#2}}

%\providecommand{\prvfsym}{f}
%\providecommand{\ffncUL}[3]{\funcitUL{\prvfsym}{#1}{#2}{#3}}
%\providecommand{\ffnc}[2][{\ssiz}]{\ffncUL{}{#1}{#2}}
%\providecommand{\fsqfnc}[2][{\ssiz}]{\ffncUL{2}{#1}{#2}}
%\providecommand{\ffncp}[2][{\ssiz}]{\ffncUL{\prime}{#1}{#2}}

%% bias
%\providecommand{\prvbterm}[3]{\funcitUL{\vect{b}}{#1}{#2}{#3}}
%\providecommand{\buterm}[1][{}]{\prvbterm{#1}{\ssiz}{\pvmu, \pvsig}}
%\providecommand{\bterm}{\buterm[{}]}
%\providecommand{\bsqterm}{\buterm[\trsym]\buterm}

%% conditional bias
%\providecommand{\prvBterm}[3]{\funcitUL{\vect{B}}{#1}{#2}{#3}}
%\providecommand{\Buterm}[1][{}]{\prvBterm{#1}{\ssiz}{\pvmu, \pvsig, \pfacsig}}
%\providecommand{\Bterm}{\Buterm[{}]}
%\providecommand{\Bsqterm}{\Buterm[\trsym]\Buterm}

%\providecommand{\sphere}[1]{\mathUL{\mathcal{S}}{#1}{}}
%\providecommand{\spherep}{\sphere{\nlatf - 1}}
%\providecommand{\fnorm}[1]{\funcitUL{f}{}{\mathcal{S}}{#1}}
%\providecommand{\sportwfnc}[1]{\funcit{\sportw}{#1}}

%\providecommand{\sportWfnc}[1]{\funcit{\sportW}{#1}}

%\providecommand{\spang}{\MATHIT{\theta}}
%\providecommand{\spangfnc}[1]{\funcit{\spang}{#1}}
%\providecommand{\spperp}{\mathUL{\pportw}{}{\bottom}}
%\providecommand{\spperpfnc}[1]{\funcitUL{\pportw}{}{\bottom}{#1}}

%%\providecommand{\prskvecU}[1]{\vectUL{\eta}{#1}{*}}
%\providecommand{\prskvecU}[1]{\vectUL{\eta}{#1}{}}
%\providecommand{\prskvec}{\prskvecU{}}
%\providecommand{\gramprskvec}{\prskvecU{\trsym}\prskvec}
%\providecommand{\ogramprskvec}{\prskvec\prskvecU{\trsym}}
%\providecommand{\Drv}{\Mtx{D}}

%\providecommand{\prskMtxU}[1]{\MtxUL{H}{#1}{}}
%\providecommand{\prskMtx}{\prskMtxU{}}
%\providecommand{\gramprskMtx}{\prskMtxU{\trsym}\prskMtx}

%\providecommand{\zvc}{\vect{z}}
%\providecommand{\farcsin}[1]{\funcit{\arcsin}{#1}}
%\providecommand{\farccos}[1]{\funcit{\arccos}{#1}}
%\providecommand{\farctan}[1]{\funcit{\arctan}{#1}}
%\providecommand{\farctanh}[1]{\funcitUL{\tanh}{-1}{}{#1}}

%\providecommand{\zzvc}{\vect{z}}
%\providecommand{\Cmat}{\Mtx{C}}
%\providecommand{\Vmat}{\Mtx{V}}
%\providecommand{\Jmat}{\Mtx{J}}
%\providecommand{\Qmat}{\Mtx{Q}}
%\providecommand{\scoro}[2]{\gradof[{#1}]{\log #2}}

%%\providecommand{\txtQual}{quality\xspace}
%\providecommand{\txtQual}{\txtSNR}
%\providecommand{\txtKS}{Kolmogorov-Smirnov\xspace}
%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% document incantations%FOLDUP
\begin{document}

\title{Inference on Achieved Signal Noise Ratio}
\author{Steven E. Pav \thanks{\email{steven@gilgamath.com}
The code to build this document is available at
\href{http://www.github.com/shabbychef/snrinf}{\normalfont\texttt{www.github.com/shabbychef/snrinf}}.
This revision was built from commit \texttt{\gitHash} of that repo.
}}
%\date{\today, \currenttime}

\maketitle
%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}%FOLDUP
We describe a procedure to perform approximate inference on the
achieved signal-noise ratio of the \txtMP under Gaussian \iid returns.
The procedure relies on a statistic similar to the Sharpe Ratio Information
Criterion. \cite{doi:10.1080/14697688.2020.1718746}
Testing indicates the procedure is somewhat conservative, but
otherwise works well for reasonable values of sample and asset universe sizes.
%We adapt the procedure to deal with generalizations of the portfolio optimization problem.
\end{abstract}%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}%FOLDUP

For a universe of \nstrat assets, 
we consider the portfolio optimization problem
\begin{equation}
\max_{\pportw }
\frac{\trAB{\pportw}{\pvmu}}{\sqrt{\qform{\pvsig}{\pportw}}}.
\label{eqn:opt_port_I}
\end{equation}
Here \pvmu is the expected return and \pvsig is the covariance of returns.
This problem is solved by the \txtMP, defined as 
\begin{equation}
\pportwopt \defeq \minvAB{\pvsig}{\pvmu},
\end{equation}
and any positive multiple thereof.

In practice the parameters \pvmu and \pvsig are unknown and must be estimated from the data. 
The estimation of parameters is known to deterioriate the quality of the
portfolio.  \cite{michaud1989markowitz}
The \txtSNR of the \txtMP, its mean divided by its volatility, is subject to a 
fundamental bound. \cite{pav2014qbounds,ao2017solving}
While inference on the population parameters follows from classical statistics
via the connection to Hotelling's $T^2$, little is known about performing
inference on the \txtSNR achieved by the \txtMP.
Paulsen and S\"{o}hl described the \emph{Sharpe Ratio Information Criterion} (SRIC), 
which is an approximately unbiased estimator for this quantity.  \cite{doi:10.1080/14697688.2020.1718746}
Some asymptotic confidence intervals have also been described, but these
require unreasonably large sample sizes. \cite{pav2013markowitz}
Here we fill this gap, describing confidence intervals very similar
to the SRIC and using the same approximation.
Practical construction of these bounds requires one to estimate the population
effect size.
In practice this causes the confidence intervals to be slightly conservative.
%Finally we expand the procedure to perform inference under hedging constraints.

%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Procedure}%FOLDUP

Assume you observe returns on \nstrat assets, 
which are independently drawn from a Gaussian distribution
$\reti[t]\sim\normlaw{\pvmu,\pvsig}$.
The population \txtMP is $\pportwopt=\minv{\pvsig}\pvmu$.
The \txtSNR of this portfolio is $\psnropt=\sqrt{\qiform{\pvsig}{\pvmu}}$.
Given \ssiz observations of returns, 
one typically estimates the population parameters via
\begin{align}
 \svmu &= \oneby{\ssiz} \sum_{1\le t \le \ssiz} \reti[t],\\
 \svsig &= \oneby{\ssiz-1} \sum_{1\le t \le \ssiz} \reti[t]\tr{\reti[t]} -
  \frac{\ssiz}{\ssiz-1}\svmu\tr{\svmu}.
\end{align}
The (sample) \txtMP is $\sportwopt=\minv{\svsig}\svmu$.
The \txtASNR of \sportwopt is defined as
\begin{equation}
  \psnr[a] \defeq \frac{\tr{\pvmu}\sportwopt}{\sqrt{\qform{\pvsig}{\sportwopt}}}.
\end{equation}
It is an unobservable random quantity that we wish to perform inference on.

The \txtSR of \sportwopt is defined as
\begin{equation}
  \ssropt \defeq \frac{\tr{\svmu}\sportwopt}{\sqrt{\qform{\svsig}{\sportwopt}}}
  = \sqrt{\qiform{\svsig}{\svmu}}.
\end{equation}
We note that $T^2=\ssiz\ssrsqopt$ is the familiar Hotelling's statistic,
which is usually prescribed to perform inference on \pvmu, but
can be used to perform inference on \psnrsqopt.
\cite{anderson2003introduction,pav_the_book}

The Sharpe Ratio Information Criterion is defined as 
\cite{doi:10.1080/14697688.2020.1718746}
\begin{equation}
  SRIC \defeq \ssropt - \frac{\nstrat-1}{\ssiz\ssropt}.
\end{equation}
Under the simplifying approximation
\begin{equation}
\label{apx:perfect_cov}
\svsig \approx \pvsig,
\end{equation}
the SRIC is unbiased for the \txtASNR:
\begin{equation}
\E{SRIC} = \E{\psnr[a]}.
\label{eqn:sric_raison_detre}
\end{equation}
Note this only holds for $\nstrat > 1$, but it is simple to express
$\E{\psnr[a]}$ when $\nstrat=1$.

Inspired by the SRIC, we seek a constant $\cono[{\typeI}]$ such that
\begin{equation}
  \Pr{\psnr[a] \le \ssropt - \frac{\cono[{\typeI}]}{\ssiz\ssropt}} = \typeI.
  \label{eqn:psnr_ci_bound}
\end{equation}
%\label{eqn:asnr_ci}
%\Pr{\ssropt - \frac{\chisqqnt{1-\typeI}{\nstrat, \frac{\ssiz\psnrsqopt}{4}} - \frac{\ssiz\psnrsqopt}{4}}{\ssiz\ssropt} \ge \pql{\sportwopt}} = \typeI.
Under \apxref{perfect_cov},
\begin{equation}
  \psnr[a] 
  \approx
  \frac{\tr{\pvmu}\minv{\pvsig}\svmu}{\sqrt{\qform{\pvsig}{\wrapParens{\minv{\pvsig}\svmu}}}}
  = \frac{\tr{\pvmu}\minv{\pvsig}\svmu}{\sqrt{\qiform{\pvsig}{\svmu}}}
  = \frac{\tr{\pvmu}\minv{\pvsig}\svmu}{\ssropt}.
\end{equation}
Under the approximation we also have $\ssrsqopt\approx\qiform{\pvsig}{\svmu}$.
We note that for Gaussian returns, we can write
\begin{equation*}
  \svmu = \pvmu + \oneby{\sqrt{\ssiz}}\chol{\pvsig}\vect{z},
  %\svmu \sim \normlaw{\pvmu,\oneby{\ssiz}\pvsig}.
\end{equation*}
where $\vect{z} \sim\normlaw{\vzero,\eye}.$
Thus
\begin{align*}
  \ssrsqopt - \psnr[a]\ssropt 
  & \approx 
  \qiform{\pvsig}{\svmu} - \tr{\pvmu}\minv{\pvsig}\svmu,\\
  &=
  \tr{\wrapParens{\svmu-\pvmu}}\minv{\pvsig}\svmu,\\
  &=
  \oneby{\ssiz}
  \tr{\vect{z}}\trchol{\pvsig}
  \minv{\pvsig}
  \wrapParens{\sqrt{\ssiz}\pvmu + \chol{\pvsig}\vect{z}},\\
  &=
  \oneby{\ssiz}
  \tr{\vect{z}}
  \wrapParens{\sqrt{\ssiz}\ichol{\pvsig}\pvmu + \vect{z}},\\
  &=
  \oneby{\ssiz}
  \tr{\wrapParens{\half\sqrt{\ssiz}\ichol{\pvsig}\pvmu + \vect{z} - \half\sqrt{\ssiz}\ichol{\pvsig}\pvmu}}
     \wrapParens{\half\sqrt{\ssiz}\ichol{\pvsig}\pvmu + \vect{z} + \half\sqrt{\ssiz}\ichol{\pvsig}\pvmu},\\
  &=
  \oneby{\ssiz}\wrapParens{
    \norm{\half\sqrt{\ssiz}\ichol{\pvsig}\pvmu + \vect{z}}^2
    - \norm{\half\sqrt{\ssiz}\ichol{\pvsig}\pvmu}^2},\\
  &\sim
  \oneby{\ssiz}\wrapParens{\chisqlaw{\nstrat,\frac{\ssiz\psnrsqopt}{4}} - \frac{\ssiz\psnrsqopt}{4}}.
\end{align*}%

Now because 
$$
\psnr[a] \le \ssropt - \frac{c}{\ssiz\ssropt} 
  \Leftrightarrow c \le \ssiz \wrapParens{\ssrsqopt - \psnr[a]\ssropt},
$$
%Thus $\ichol{\pvsig}\svmu \sim
%\normlaw{\ichol{\pvsig}\pvmu,\oneby{\ssiz}\eye},$ where $\ichol{\pvsig}$ is the
%inverse of the (symmetric) square root of \pvsig.
%Note that $\norm{\ichol{\pvsig}\pvmu}=\psnropt$.
%
%Now take \Mtx{P} to be a orthogonal matrix that rotates $\ichol{\pvsig}\pvmu$
%onto $\psnropt\basev[1]$.
%Then $\Mtx{P}\ichol{\pvsig}\svmu\sim\normlaw{\psnropt\basev[1],\oneby{\ssiz}\eye}$.
%Thus
%\begin{align*}
%\tr{\pvmu}\minv{\pvsig}\svmu 
%&= \tr{\pvmu}\trichol{\pvsig}\tr{\Mtx{P}}\Mtx{P}\ichol{\pvsig}\svmu
%= \psnropt\trbasev[1]\Mtx{P}\ichol{\pvsig}\svmu
%\sim 
  %\frac{\psnropt}{\sqrt{\ssiz}}\wrapParens{\sqrt{\ssiz}\psnropt + z_1},\\
  %%\psnrsqopt + \frac{\psnropt}{\sqrt{\ssiz}}z_1,\\  %\normlaw{\psnrsqopt,\frac{\psnrsqopt}{\ssiz}}.
  %\qiform{\pvsig}{\svmu} 
%&= \tr{\svmu}\trichol{\pvsig}\tr{\Mtx{P}}\Mtx{P}\ichol{\pvsig}\svmu
  %\sim \oneby{\ssiz}\wrapParens{\sqrt{\ssiz}\psnropt + z_1}^2 + \oneby{\ssiz}\sum_{2 \le i \le \nstrat}z_i^2,
%\end{align*}
%where the $z_i$ are independent standard Gaussians.
%
%Then we have
%\begin{align*}
  %\psnr[a] \le \ssropt - \frac{c}{\ssiz\ssropt} 
  %&\Leftrightarrow \psnr[a]\ssropt \le \ssrsqopt - \frac{c}{\ssiz},\\
  %&\Leftrightarrow \tr{\pvmu}\minv{\pvsig}\svmu \le \qiform{\pvsig}{\svmu} - \frac{c}{\ssiz},\\
  %&\Leftrightarrow 
  %\frac{\psnropt}{\sqrt{\ssiz}}\wrapParens{\sqrt{\ssiz}\psnropt + z_1}
  %\le 
  %\oneby{\ssiz}\wrapParens{\sqrt{\ssiz}\psnropt + z_1}^2 +
  %\oneby{\ssiz}\sum_{2 \le i \le \nstrat}z_i^2 - \frac{c}{\ssiz},\\
  %&\Leftrightarrow 
  %c \le 
  %\wrapParens{\sqrt{\ssiz}\psnropt + z_1}^2 
  %-\sqrt{\ssiz}\psnropt\wrapParens{\sqrt{\ssiz}\psnropt + z_1}
  %+ \sum_{2 \le i \le \nstrat}z_i^2,\\
  %&\Leftrightarrow 
  %c \le 
  %\wrapParens{\frac{\sqrt{\ssiz}\psnropt}{2} + z_1}^2 
  %-\frac{\ssiz\psnrsqopt}{4} 
  %+ \sum_{2 \le i \le \nstrat}z_i^2.
%\end{align*}
If we want this condition to hold with probability \typeI we should set
\begin{equation}
\cono[\typeI] = {\chisqqnt{1-\typeI}{\nstrat, \frac{\ssiz\psnrsqopt}{4}} - \frac{\ssiz\psnrsqopt}{4}},
\end{equation}
where \chisqqnt{q}{\df,\nctp} is the $q$ quantile of the non-central chi-square distribution
with \df degrees of freedom and non-centrality parameter \nctp.

\paragraph{Checking Coverage}

%\begin{example}[CI Coverage]%FOLDUP
%\label{example:b9d63112-6dd5-487e-8734-d17bc26740f9}
% from my blog post gilgamath/bad-ci
<<'badci_setup',dependson=c('setup'),results='hide'>>=
suppressMessages({
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(SharpeR)
  library(future.apply)
})

# one simulation of n periods of data on p assets with true optimal
# SNR of (the vector of) pzeta
onesim <- function(pzeta,n,p) {
  pmus <- pzeta / sqrt(p)
  # simulate an X: too slow.
  #X <- matrix(rnorm(n*p,mean=pmus[1],sd=1),ncol=p)
  #smu1 <- colMeans(X)
  #ssig <- ((n-1)/n) * cov(X)
  # this is faster:
  smu1 <- rnorm(p,mean=pmus[1],sd=1 / sqrt(n))
  ssig <- rWishart(1,df=n-1,Sigma=diag(1,ncol=p,nrow=p)) / n  # sic n
  dim(ssig) <- c(p,p)

  smus <- outer(smu1,pmus - pmus[1],FUN='+')
  smps <- solve(ssig,smus)
  szeta <- sqrt(colSums(smus * smps))
  psnr <- pmus * as.numeric(colSums(smps) / sqrt(colSums(smps^2)))
  cbind(pzeta,szeta,psnr)
}
# do that many times.
repsim <- function(nrep,zetas,n,p) {
  foo <- future_replicate(nrep,onesim(pzeta=zetas,n,p))
  baz <- aperm(foo,c(1,3,2))
  dim(baz) <- c(nrep * length(zetas),dim(foo)[2])
  colnames(baz) <- colnames(foo)
  invisible(as.data.frame(baz))
}

# actually do it many times.
ope <- 252
zetasq <- c(1/4,1,4) / ope
zeta <- sqrt(zetasq)

params <- tidyr::crossing(tibble::tibble(n=round(100*2^(-1:10))),
                          tibble::tibble(p=2^(1:4))) %>%
  filter(n > 10 * p) %>%
  filter(n < 20000 * p)

# this good?
# 100K takes maybe 3 minutes?
# 250K takes 8 minutes on my 8 core desktop
# 500K takes 15.5 minutes on my 8 core desktop
nrep <- 1000000L

plan(multiprocess)
set.seed(2356)
system.time({
results <- params %>%
  group_by(n,p) %>%
    summarize(sims=list(repsim(nrep=nrep,zetas=zeta,n=n,p=p))) %>%
  ungroup() %>%
  tidyr::unnest()
})
plan(sequential)
@
Before proceeding, we check whether use of \apxref{perfect_cov}
leads to a degradation in coverage of a confidence interval implied by \ineqnref{psnr_ci_bound}.
We draw \ssiz days of returns from the $\nstrat$-variate normal distribution.
For a fixed value of \psnropt, we perform 
$\Sexpr{nrep}$ simulations of computing $\psnr[a]$ and \ssrsqopt, computing a
one-sided confidence bound and measuring the empirical rate of type I errors.
We then let \ssiz vary from \Sexpr{min(params$n)} to $\Sexpr{prty(max(params$n))}$ days; 
we let \nstrat vary from \Sexpr{min(params$p)} to \Sexpr{max(params$p)};
we let \psnropt vary from $\Sexpr{min(zeta)*sqrt(ope)}\,\yrtomhalf$ to $\Sexpr{max(zeta)*sqrt(ope)}\,\yrtomhalf$, where we assume
\Sexpr{ope} days per year. 
We compute the lower confidence limit on $\psnr[a]$ using knowledge of the
actual \psnropt to construct \cono[\typeI].
For practical inference this would
have to be estimated, but here we are only testing conditions for which the 
approximation $\svsig\approx\pvsig$ is close enough for purposes of inference.

%For $\kurty=1$, we draw from a multivariate normal; for 
%$\kurty > 1$, we draw from a multivariate shifted $t$ distribution.
%
<<'badci_collect_sims',dependson=c('badci_setup'),results='hide'>>=
kurty <- 1

midres <- results %>%
  distinct(pzeta,p) %>%
  mutate(bit1 = (kurty*pzeta^2 + 1) * (1 - p),
         bit2 = (3 * kurty - 1) * ((pzeta^2)/4) + 1) 

typeI <- 0.05
#qval <- 0.5

# invert the TAS function
anti_tas <- function(x) { x / sqrt(1 + x^2) }

# confidence intervals and coverage:
# this takes 10 times longer than the simulations? wtaf?
system.time({
  # wow, slow.
  qalpha <- qnorm(typeI)

foores <- results %>%
  distinct(n,pzeta,p) %>%
  #mutate(bit1 = (kurty*pzeta^2 + 1) * (1 - p),
         #bit2 = (3 * kurty - 1) * ((pzeta^2)/4) + 1) %>%
  #mutate(addon = ((bit1 + bit2) / (2 * n * pzeta)) + qalpha * sqrt(bit2/n)) %>%
  #mutate(mlton = (1 + ((bit1 + 3 * bit2) / (2 * n * pzeta * pzeta)) + qalpha * sqrt(bit2 / (n*pzeta*pzeta)))) %>%
  #mutate(kurty=kurty) %>%
  #mutate(lam1=pzeta*sqrt((2+3*(kurty-1))/(4*n)),
         #lamp=sqrt(1 + kurty*pzeta^2)/sqrt(n)) %>%
  mutate(cons = qchisq(1-typeI,df=p,ncp=n*pzeta*pzeta/4) - n*pzeta*pzeta/4) 

cires <- results %>%
  left_join(foores,by=c('pzeta','p','n')) %>%
  #mutate(tpart=qt(typeI,df=p-1,ncp=szeta/lam1)) %>%
  #mutate(ci_add = szeta + addon) %>%
  #mutate(ci_div = szeta * mlton) %>%
  #mutate(ci_tas = pzeta * anti_tas((lam1 * tpart) / (lamp * sqrt(p-1)))) %>%
  mutate(ci_new = szeta - cons / (n*szeta)) %>%
  group_by(pzeta,n,p) %>%
    summarize(#type1_add = mean(psnr < ci_add),
              #type1_div = mean(psnr < ci_div),
              #type1_tas = mean(psnr < ci_tas),
              type1_new = mean(psnr < ci_new)) %>%
  ungroup() %>%
  mutate(zyr=signif(pzeta * sqrt(ope),digits=2)) %>%
  rename(`annualized SNR`=zyr) 
})
@
<<'badci_ci_plots',dependson=c('badci_collect_sims'),fig.width=cfg_width,fig.height=cfg_height,out.width=cot_width,out.height=cot_height,fig.cap=fig_cap>>=
fig_cap <- paste0("The empirical type I rate, over ",prty(nrep)," simulations, of a one-sided confidence bound for $\\psnr_{a}$ are shown ",
                  "for a nominal type I rate of $",typeI,"$. The daily returns are drawn from multivariate normal distribution with varying \\psnropt, \\ssiz, and \\nstrat. ",
                  "Type I rates are plotted versus $\\ssiz/\\nstrat$ to indicate the requisite aspect ratio to achieve near nominal coverage. ")
									#"The confidence intervals generally fail to achieve the nominal rate except for unrealistically large values of \\ssiz. ")

# plot CIs:
library(ggplot2)
ph <- cires %>%
  tidyr::gather(key=type,value=type1,matches('^type1_')) %>%
	mutate(type=case_when(.$type=='type1_add' ~ 'difference',
												.$type=='type1_div' ~ 'product',
												.$type=='type1_tas' ~ 'tas',
												.$type=='type1_new' ~ 'SRIC',
												TRUE ~ 'bad code')) %>%
  mutate(type=factor(type,levels=c('SRIC','difference','product','tas'))) %>%
  filter(as.character(type)=='SRIC') %>%
  rename(k=p) %>%
  mutate(xrat=n/k) %>%
  ggplot(aes(xrat,type1,color=factor(k))) +
  geom_line() + geom_point() + 
  #facet_grid(k ~ `annualized SNR`,scales='free',labeller=label_both) + 
  facet_grid(. ~ `annualized SNR`,scales='free',labeller=label_both) + 
  scale_x_log10() +
  #scale_y_sqrt() + 
  scale_y_continuous() + 
  geom_hline(yintercept=0.05,linetype=2,alpha=0.5) + 
  labs(x=expression(n/k),
       y='empirical type I rates at nominal 0.05 level',
       color=expression(k),
       shape=expression(k),
       #color='CI Bound',shape='CI Bound',
       title='Coverage of CIs on achieved SNR of the Markowitz portfolio\nGaussian returns, using clairvoyance.')
print(finish_plot(ph))
rm(cires)
@
In \figref{badci_ci_plots} we plot the empirical type I rate at the nominal
\Sexpr{typeI} level of the confidence bound. 
The main takeaway from this experiment is that the bound gives near-nominal
coverage when $\ssiz \ge 100\nstrat$ or so.
%The `difference' bound takes the form $\ssropt - c$,
%while the `product' form is $c\ssropt$. 
%The `TAS' bound is built on the \fntas{x} function of \eqnref{def_fntas}.
%The `SRIC' bound is the one given in \eqnref{asnr_ci}.
%We restrict the $y$ axis to an area around the nominal rate to show detail,
%which causes some of the lines to entirely fall off the plot.
%The main takeaways from this experiment are that the SRIC bound 
%performs much better than the asymptotic bounds, giving near-nominal
%coverage for much of the parameter space considered here, 
%and that the approximation required for the SRIC bound does not seem
%to cause issues except when $\ssiz \le 100\nstrat$ or so.
%\end{example}%UNFOLD

% cf my diary file from which has some stuff on this.
% * Mon May 13 2019 09:14:11 PM Steven E. Pav steven@gilgamath.com 

\subsection{Practical Inference}

One can construct one- or two-sided confidence intervals from \ineqnref{psnr_ci_bound} when \psnropt is known.
However, it is unknown in practice, and the constant $\cono[\typeI]$ is sufficiently sensitive to it.
To practically perform inference, there are two obvious routes: one is to
jointly perform inference on \psnropt on \psnr[a]; 
the other is to estimate \psnropt and plug it in when constructing \cono[\typeI].

For the joint estimation procedure, for some $q \in \oointerval{0}{1}$,
construct a $q \typeI$ upper bound on \psnropt.
That confidence bound can be described implicitly via the connection 
to the non-central \flaw{} distribution:
to find the one-sided confidence intervals $\ccinterval{0}{\psnr[u]}$ with
coverage $1-q\typeI$, find
\begin{equation}
\psnr[u] = \min \setwo{z}{z \ge 0,\,\,\typeI/2 \ge \ncfcdf{\wrapNeParens{\frac{\ssiz (\ssiz-\nstrat)}{\nstrat (\ssiz - 1)}}\ssrsqopt}{\nstrat,\ssiz - \nstrat}{\ssiz z^2}},
%\typeI/2 = \ncfcdf{\wrapNeParens{\frac{\ssiz (\ssiz-\nstrat)}{\nstrat (\ssiz - 1)}}\ssrsqopt}{\nstrat,\ssiz - \nstrat}{\ssiz\psnr[u]^2},
%\label{eqn:optsnrcis_I}
\end{equation}
where $\ncfcdf{x}{\nctdf[1],\nctdf[2]}{\ncfp}$ is the CDF of the non-central
\flaw{}-distribution with 
non-centrality parameter \ncfp and $\nctdf[1]$ and $\nctdf[2]$ degrees of freedom.
This method requires computational inversion of the CDF function. 
Then compute
$$
c = \max \wrapBraces{\left. \chisqqnt{1-\wrapNeParens{1-q}\typeI}{\nstrat,
\frac{\ssiz\psnr^2}{4}} - \frac{\ssiz\psnr^2}{4} \right|  0 \le \psnr[u]}.
$$
The bound $\ssropt - \frac{c}{\ssiz\ssropt}$ then should
have type I rate at most \typeI.
However, since this is a joint confidence bound the bound on \psnr[a] will be
somewhat conservative.

Another approach, which does not have guaranteed coverage, is to
estimate \psnropt from the data, and plug in that value in the computation of
\cono[\typeI].
We can perform this estimation using standard techniques, 
again via the connection of Hotelling's $T^2$ to the \flaw{} distribution.
Kubokawa, Robert and Saleh described improved methods for estimating
the non-centrality parameter given an observation of a non-central
\flaw{} statistic. \cite{kubokawa1993estimation}.
They described the following estimators for the non-centrality parameter,
which is \psnrsqopt in our case:
\begin{equation}
\label{eqn:KRS_estimators}
\begin{split}
	\delta_0 &= \frac{\wrapParens{\dftwo-2}}{\ssiz-1}\ssrsqopt - \frac{\nstrat}{\ssiz},\\
	\delta_1 &= \fmax{\delta_0,0},\\
	\delta_2 &= \fmax{\delta_0,\frac{2}{\nstrat+2}\wrapParens{\delta_0 + \frac{\nstrat}{\ssiz}}}.
\end{split}
\end{equation}
They note that $\delta_0$ is the Uniform Minimum Variance Unbiased Estimator (UMVUE) of \psnrsqopt.
However, it can be negative.
The estimators $\delta_1, \delta_2$ are non-negative, and dominate $\delta_0$ in having
lower expected squared error.
Thus the suggested procedure is to compute
$$
c = \chisqqnt{1-\typeI}{\nstrat, \frac{\ssiz\delta_2}{4}} - \frac{\ssiz\delta_2}{4},
$$
then use the bound $\ssropt - \frac{c}{\ssiz\ssropt}$.
In practice this bound seems to give slightly less conservative coverage than
the joint bound described above.
It is not clear how to find a coverage guarantee for this bound.
The quantities \ssrsqopt and \psnr[a] are not independent, 
and their asymptotic correlation is $\bigo{\ssiz^{-\halff}}$, which is only slowly shrinking. \cite{pav2013markowitz}

%\begin{example}[Feasible CI Coverage]%FOLDUP
\paragraph{Feasible CI Coverage}
%\label{example:64cb27b2-e7d9-4e38-968e-0d6cbf4a2f63}
<<'feasible_ci_sims',dependson=c('badci_collect_sims'),results='hide'>>=
typeI <- 0.05
qval <- 0.25

Ffoo <- function(zval,fval,ssiz,df1,df2) {
	pf(fval,df1=df1,df2=df2,ncp=ssiz*zval^2)
}
qlim <- function(ssrsqopt,ssiz,nstrat,df1=nstrat,df2=ssiz-nstrat,lvl=0.025) {
	fval <- (ssiz/(ssiz-1)) * (df2/df1) * ssrsqopt
	ofunc <- function(z) { lvl - Ffoo(z,fval,ssiz=ssiz,df1=df1,df2=df2) }
	if (ofunc(0) > 0) { return(0) }
	zval <- uniroot(ofunc,lower=0,upper=20)$root
	return(zval)
}
foo_cibound <- function(ssrsqopt,ssiz,nstrat,alpha=0.05,q=0.5) {
  # upper bound on psnropt
  ub <- qlim(ssrsqopt,ssiz,nstrat,lvl=q*alpha)
  ssropt <- sqrt(ssrsqopt)
  cons <- qchisq(1-(1-q)*typeI,df=nstrat,ncp=ssiz*ub*ub/4) - ssiz*ub*ub/4
  foobound <- ssropt - cons / (ssiz*ssropt)
}

# ignores q
baz_cibound <- function(ssrsqopt,ssiz,nstrat,alpha=0.05,...) {
  # make ub via delta_2
	df2 <- ssiz - nstrat
	delta0 <- ((df2 - 2) / (ssiz-1)) * ssrsqopt - (nstrat/ssiz)
	delta2 <- pmax(delta0,(2/(nstrat+2)) * (delta0 + (nstrat/ssiz)))
  ub <- sqrt(delta2)
  ssropt <- sqrt(ssrsqopt)
  cons <- qchisq(1-typeI,df=nstrat,ncp=ssiz*ub*ub/4) - ssiz*ub*ub/4
  foobound <- ssropt - cons / (ssiz*ssropt)
}

ary_bound <- function(ssrsqopts,ssiz,nstrat,alpha=0.05,q=0.5,type=c('delta','worse')) {
	type <- match.arg(type)
  bdfnc <- switch(type,
                  delta=baz_cibound,
                  worse=foo_cibound)
  ylims <- future_sapply(ssrsqopts,bdfnc,ssiz=ssiz,nstrat=nstrat,alpha=alpha,q=q)
}

iry_bound <- function(ssrsqopts,ssiz,nstrat,alpha=0.05,q=0.5,type=c('delta','worse')) {
	type <- match.arg(type)
  xlims <- seq(0.95*min(ssrsqopts),1.05*max(ssrsqopts),length.out=1001)
  ylims <- ary_bound(ssrsqopts=xlims,ssiz=ssiz,nstrat=nstrat,alpha=alpha,q=q,type=type)
  # now interpolate
  newfun <- approxfun(xlims,ylims)
  yout <- newfun(ssrsqopts)
}

#system.time({
  plan(multiprocess)
  # wow, slow.
  nures <- results %>%
    group_by(n,p) %>%
      mutate(ci_del = iry_bound(szeta^2,ssiz=first(n),nstrat=first(p),alpha=typeI,q=qval,type='delta'),
             ci_wrs = iry_bound(szeta^2,ssiz=first(n),nstrat=first(p),alpha=typeI,q=qval,type='worse')) %>%
    ungroup() %>%
    group_by(n,p,pzeta) %>%
      summarize(type1_del = mean(psnr < ci_del),
                type1_wrs = mean(psnr < ci_wrs)) %>%
    ungroup() 
  plan(sequential)
  rm(results)
#})
@
We reconsider the experiments above %of \exampleref{b9d63112-6dd5-487e-8734-d17bc26740f9},
but compute feasible confidence bounds.
We use both the simultaneous CI approach with $q=\Sexpr{qval}$; 
and plug in $\psnropt=\sqrt{\delta_2}$ to construct the bound.
In \figref{feasible_ci_plots}, we plot the empirical type I rate for both of these bounds
versus \ssiz, with facets for \psnropt and \nstrat.
We see that the $\delta_2$ plug-in estimator has coverage closer to the nominal $\Sexpr{typeI}$ rate.
Both bounds have issues when $\ssiz/\nstrat$ is not sufficiently large, a problem stemming
from the poor quality of the approximation $\svsig\approx\svsig$, and which was seen
above.
However, here we see closer to nominal coverage for larger \nstrat for both methods.
It is not clear how the coverage will behave for larger $\ssiz/\nstrat$, though
that seems like an unlikely problem in practice.
%in the previous example.
%
<<'feasible_ci_plots',dependson=c('feasible_ci_sims'),fig.width=cfg_width,fig.height=cfg_height,out.width=cot_width,out.height=cot_height,fig.cap=fig_cap>>=
fig_cap <- paste0("The empirical type I rate, over ",prty(nrep)," simulations, of two feasible one-sided confidence bounds for $\\psnr_{a}$ are shown ",
                  "for a nominal type I rate of $",typeI,"$. The daily returns are drawn from multivariate normal distribution with varying \\psnropt, \\ssiz, and \\nlatf. ",
                  "The $y$ axis is drawn in square root scale to show detail. ")

# plot CIs:
library(ggplot2)
ph <- nures %>%
  mutate(zyr=signif(pzeta * sqrt(ope),digits=2)) %>%
  rename(`annualized SNR`=zyr) %>%
  tidyr::gather(key=type,value=type1,matches('^type1_')) %>%
	mutate(type=case_when(.$type=='type1_del' ~ 'delta2',
                        .$type=='type1_wrs' ~ 'joint',
												TRUE ~ 'bad code')) %>%
  rename(k=p) %>%
  mutate(xrat=n/k) %>%
  ggplot(aes(xrat,type1,linetype=type,shape=type,color=factor(k))) +
  geom_line() + geom_point(aes(shape=type)) + 
  #facet_grid(k ~ `annualized SNR`,scales='free',labeller=label_both) + 
  facet_grid(. ~ `annualized SNR`,scales='free',labeller=label_both) + 
  geom_hline(yintercept=0.05,linetype=2,alpha=0.5) + 
  scale_x_log10() +
  scale_y_sqrt() + 
  #scale_y_continuous() + 
  labs(x=expression(n/k),
       y='empirical type I rates at nominal 0.05 level',
       color=expression(k),
       linetype='CI Bound',shape='CI Bound',
       title='Coverage of CIs on achieved SNR of the Markowitz portfolio\nGaussian returns, feasible CI')
print(finish_plot(ph))
@
%\end{example}%UNFOLD

\subsection{Hedged Portfolios}%FOLDUP

Now we generalize the portfolio problem of \eqnref{opt_port_I} to add a hedging constraint.
So consider the constrained portfolio optimization problem on \nstrat assets,
%\begin{empheq}[box={\eqnbox[10pt][10pt]}]{equation}
\begin{equation}
  \max_{\substack{\hejG\pvsig \pportw = \vzero,\\ \qform{\pvsig}{\pportw} \le \Rbuj^2}}
\frac{\trAB{\pportw}{\pvmu} - \rfr}{\sqrt{\qform{\pvsig}{\pportw}}},
\label{eqn:opt_port_hedge}
\end{equation}
%\end{empheq}
where $\hejG$ is an $\nstrathej \times \nstrat$ matrix of rank \nstrathej, and,
as previously, \pvmu, \pvsig are the mean vector and covariance matrix, 
\rfr is the risk-free rate, and $\Rbuj > 0$ is a risk `budget'. 
We can interpret
the \hejG constraint as stating that the covariance of the returns of
a feasible portfolio with the returns of a portfolio whose weights are in
a given row of \hejG shall equal zero. %the corresponding element of \hejg.
In the garden variety application of this problem, \hejG consists of 
\nstrathej rows of the identity matrix; %, and \hejg is the zero vector;
in this case, feasible portfolios are \emph{hedged} with respect 
to the \nstrathej assets selected by \hejG
(although they may hold some position in the hedged assets).
We use ``hedged'' to mean a portfolio with zero covariance 
against some other portfolio(s).
%\index{portfolio constraints!hedging!definition|textbf}

%% not a problem when the hejg is zero
%Assuming that
%the \hejG constraint and risk budget can be simultaneously satisfied,
%the
The
solution to this problem, via the Lagrange multiplier technique,
is
%\begin{equation}
  %\label{eqn:opt_port_solve_hedge}
  %\begin{split}
  %\pportwopt &= c\wrapParens{\minv{\pvsig}{\pvmu} -
  %\qiform{\wrapParens{\qoform{\pvsig}{\hejG}}}{\hejG}\pvmu} +
  %\tr{\hejG}{\minv{\wrapParens{\qoform{\pvsig}{\hejG}}}}\hejg,\,\\
    %\mbox{where } c^2 &= \frac{\Rbuj^2 - \qform{\wrapParens{\qoform{\pvsig}{\hejG}}}{\hejg}}{
  %\qiform{\pvsig}{\pvmu} -
  %\qiform{\wrapParens{\qoform{\pvsig}{\hejG}}}{\wrapParens{\hejG\pvmu}}},
  %\end{split}
%\end{equation}
%where the numerator in the last equation must be positive for the problem
%to be feasible.
%The case where $\hejg \ne 0$ is `pathological', as it requires a fixed
%non-zero covariance of the target portfolio with some other portfolio's
%returns. 
%Setting $\hejg = 0$ ensures the problem is feasible, and
%we will make this assumption hereafter. 
%Under this assumption, the optimal
%portfolio is 
\begin{equation*}
\pportwoptHej{\hejG}
= c \wrapParens{\minv{\pvsig}{\pvmu} -
  \qiform{\wrapParens{\qoform{\pvsig}{\hejG}}}{\hejG}\pvmu}.
%= c_1 \pportwoptG{\eye} - c_2 \pportwoptG{\hejG},
\end{equation*}
%using the notation from \eqnref{opt_port_solve_cons_I}.
%The constants $c_1, c_2$ adjust for the risk budget.
%\subsecref{basic_conpo}.
When $\rfr > 0$, the unique solution is found by setting $c$ so that the risk budget is an equality.
Note that, up to scaling, $\minv{\pvsig}\pvmu$ is the unconstrained optimal
portfolio, and thus the imposition of the \hejG constraint only changes
the unconstrained portfolio in assets corresponding to columns of \hejG 
containing non-zero elements. In the garden variety application where
\hejG is a single row of the identity matrix, the imposition of the
constraint only changes the holdings in the asset to be hedged (modulo
changes in the leading constant to satisfy the risk budget).

%Without loss of generality we can assume that \hejG consists of some \nstrathej
%distinct rows of the $\sbby{\nstrat}$ identity matrix.

The squared \txtSNR of the optimal portfolio we write as 
\begin{equation}
%\psnrsqopt
\Hejpsnrsqopt{\hejG} 
\defeq 
\qiform{\pvsig}{\pvmu} - \qiform{\wrapParens{\qoform{\pvsig}{\hejG}}}{\wrapParens{\hejG\pvmu}}.
%= \psnrsqoptG{\eye} - \psnrsqoptG{\hejG},
\label{eqn:psnr_Gcons}
\end{equation}
%using the notation from 
%\eqnref{opt_port_snr_cons_I},
%%\subsecref{basic_conpo}, 
%and setting $\rfr=0$.
The sample optimal portfolio is given by 
\begin{equation*}
  \sportwoptHej{\hejG}
= c \wrapParens{\minv{\svsig}{\svmu} -
  \qiform{\wrapParens{\qoform{\svsig}{\hejG}}}{\hejG}\svmu}.
%= c_1 \sportwoptG{\eye} - c_2 \sportwoptG{\hejG},
\end{equation*}
The squared \txtSR of this portfolio is
\begin{equation}
\Hejssrsqopt{\hejG}
= \qiform{\svsig}{\svmu} -
  \qiform{\wrapParens{\qoform{\svsig}{\hejG}}}{\wrapParens{\hejG\svmu}}.
%= \ssrsqoptG{\eye} - \ssrsqoptG{\hejG},
\label{eqn:ssr_Gcons} 
\end{equation}
The \txtASNR of this portfolio is
\begin{equation}
  \psnr[a] = 
  \frac{\tr{\pvmu}\sportwoptHej{\hejG}}{\sqrt{\qform{\pvsig}{\sportwoptHej{\hejG}}}}.
\end{equation}

%follows a (central) \flaw{} distribution under the null hypothesis of $\Hejpsnrsqopt{\hejG}=0$. \cite{rao1952}
Define:
\begin{align*}
\ssrsqoptG{\hejG} &\defeq \qiform{\wrapParens{\qoform{\svsig}{\hejG}}}{\wrapParens{\hejG\svmu}}.
%\Hejpsnrsqopt{\hejG} &\defeq \qiform{\pvsig}{\pvmu} - \qiform{\wrapParens{\qoform{\pvsig}{\hejG}}}{\wrapParens{\hejG\pvmu}}.
\end{align*}
Giri showed that conditional on observing \ssrsqoptG{\hejG},
{\small
\begin{equation}
%F_{\hejG}}
\acondb{
	\frac{\ssiz}{\ssiz-1}\frac{\ssiz - \nstrat}{\nstrat - \nstrathej}\frac{\Hejssrsqopt{\hejG}}{1 +
  \frac{\ssiz}{\ssiz-1}\ssrsqoptG{\hejG}} 
}{\ssrsqoptG{\hejG}}
	\sim
\ncflaw{\nstrat-\nstrathej,\ssiz-\nstrat,\frac{\ssiz}{1 +
\frac{\ssiz}{\ssiz-1}\ssrsqoptG{\hejG}} 
%\wrapParens{\psnrsqoptG{\eye} - \psnrsqoptG{\hejG}}
	\Hejpsnrsqopt{\hejG}
	},
\label{eqn:giri_done_I}
\end{equation}%
}%
where \ncflaw{\df[1],\df[2],\ncfp} is the non-central \flaw{}-distribution
with \df[1], \df[2] degrees of freedom and non-centrality parameter
\ncfp.  \cite{giri1964likelihood,pav_the_book}

%\index{portfolio spanning}
%The quantity $\psnrsqopt$ in \eqnref{psnr_Gcons} is the
%drop in squared \txtSNR incurred by imposing the \hejG hedge constraint.
%This population quantity is the subject of inference
%in tests of \emph{portfolio spanning}.  \cite{KanZhou2012,HKspan1987}
%A spanning test considers whether the optimal portfolio on a 
%pre-fixed subset of \nstrathej assets has the same \txtSR as the
%optimal portfolio on all \nstrat assets, \ie whether those \nstrathej
%assets `span' the set of all assets.  We will consider those in the sequel.

Now we apply \apxref{perfect_cov}, and complete the square as we did in the unhedged case, to find that
{\scriptsize
\begin{align*}
  \Hejpsnrsqopt{\hejG} - \psnr[a]\sqrt{\Hejpsnrsqopt{\hejG}} 
  & \approx 
  \tr{\wrapParens{\svmu-\pvmu}}\minv{\pvsig}\svmu -
  \tr{\wrapParens{\svmu-\pvmu}}\tr{\hejG}
  \minv{\wrapParens{\qoform{\pvsig}{\hejG}}}\hejG\svmu,\\
  %&=
  %\oneby{\ssiz}
  %\wrapBracks{
  %\tr{\vect{z}}\trchol{\pvsig}
  %\minv{\pvsig}
  %\wrapParens{\sqrt{\ssiz}\pvmu + \chol{\pvsig}\vect{z}} -
  %\tr{\vect{z}}\trchol{\pvsig}\tr{\hejG}
  %\minv{\wrapParens{\qoform{\pvsig}{\hejG}}}\hejG
  %\wrapParens{\sqrt{\ssiz}\pvmu + \chol{\pvsig}\vect{z}}},\\
  &=
  \oneby{\ssiz}
  \wrapBracks{
    \qform{\wrapParens{\eye - \trchol{\pvsig}\tr{\hejG}\minv{\wrapParens{\qoform{\pvsig}{\hejG}}}\hejG\chol{\pvsig}}}{%
      \wrapParens{\half\sqrt{\ssiz}\ichol{\pvsig}\pvmu + \vect{z}}}}\\
    &\phantom{=}\,
  -\oneby{4\ssiz}
  \wrapBracks{
    \qform{\wrapParens{\eye - \trchol{\pvsig}\tr{\hejG}\minv{\wrapParens{\qoform{\pvsig}{\hejG}}}\hejG\chol{\pvsig}}}{%
      \wrapParens{\sqrt{\ssiz}\ichol{\pvsig}\pvmu}}},
  %\tr{\vect{z}}
  %\wrapParens{\sqrt{\ssiz}\ichol{\pvsig}\pvmu + \vect{z}} -
  %\tr{\vect{z}}\trchol{\pvsig}\tr{\hejG}
  %\minv{\wrapParens{\qoform{\pvsig}{\hejG}}}\hejG\chol{\pvsig}
  %\wrapParens{\sqrt{\ssiz}\ichol{\pvsig}\pvmu + \vect{z}}},
\end{align*}%
}%
where $\vect{z} \sim\normlaw{\vzero,\eye}.$
Now note that the matrix 
$$\Mtx{A} = {\eye - \trchol{\pvsig}\tr{\hejG}\minv{\wrapParens{\qoform{\pvsig}{\hejG}}}\hejG\chol{\pvsig}}$$
is idempotent with rank $\nstrat - \nstrathej$.
Thus a quadratic form in \Mtx{A} follows a non-central $\chi^2$ distribution\footnote{\emph{n.b.} the standard definition of
non-centrality parameter in the time Graybill and Marsaglia wrote their paper is different from the one we use today by a factor of
$1/2$.} with degrees of freedom equal to the rank of \Mtx{A}. \cite[Theorem 2]{10.2307/2237227}
Thus
\begin{equation*}
\Hejpsnrsqopt{\hejG} - \psnr[a]\sqrt{\Hejpsnrsqopt{\hejG}} \sim
  \oneby{\ssiz}\wrapParens{\chisqlaw{\nstrat - \nstrathej,\frac{\ssiz\Hejpsnrsqopt{\hejG}}{4}} - \frac{\ssiz\Hejpsnrsqopt{\hejG}}{4}}.
\end{equation*}

Then, as in the unhedged case, we have
\begin{equation}
  \Pr{\psnr[a] \le \sqrt{\Hejssrsqopt{\hejG}} - \frac{\cono[{\typeI}]}{\ssiz\sqrt{\Hejssrsqopt{\hejG}}}} = \typeI,
\end{equation}
if we let
$$
\cono[\typeI] = {\chisqqnt{1-\typeI}{\nstrat - \nstrathej, \frac{\ssiz\Hejpsnrsqopt{\hejG}}{4}} - \frac{\ssiz\Hejpsnrsqopt{\hejG}}{4}}.
$$
To perform feasible inference one will need to estimate \Hejpsnrsqopt{\hejG}. 
Again this will be via the connection to a non-central \flaw{}-distribution, \eqnref{giri_done_I}.
One can either find an upper quantile directly, or use a KRS-type estimator, which 
for the hedged case are 
\begin{equation}
\label{eqn:hedged_KRS_estimators}
\begin{split}
  \delta_0 &= \frac{\wrapParens{\dftwo-2}}{\ssiz-1}\Hejssrsqopt{\hejG} - \frac{\nstrat-\nstrathej}{\ssiz}\wrapParens{1 +
  \frac{\ssiz}{\ssiz-1}\ssrsqoptG{\hejG}},\\
	\delta_1 &= \fmax{\delta_0,0},\\
  \delta_2 &= \fmax{\delta_0,\frac{2}{\nstrat-\nstrathej+2}\frac{\dftwo-2}{\ssiz-1}\Hejssrsqopt{\hejG}}.
\end{split}
\end{equation}

\paragraph{Checking Coverage}

%\begin{example}[hedged CI Coverage]%FOLDUP
% welp, here we go...
<<'hejci_sims',dependson=c('setup'),results='hide'>>=
suppressMessages({
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(SharpeR)
  library(future.apply)
})

# for testing, use these
#pzeta <- 10*c(0,0.01,0.02,0.03,0.04)
#n <- 1000
#p <- 4

# here we will perform a simulation on n periods of data with 2p assets
# with equal mean across assets and compute the hedged SR for the first
# p excluding the second p.
onesim <- function(pzeta,n,p) {
  nstrat <- 2*p
  pmus <- pzeta / sqrt(nstrat)
  # simulate an X is too slow, we do multiple pzeta at once, which is hard to follow.
  smu1 <- rnorm(nstrat,mean=pmus[1],sd=1 / sqrt(n))
  ssig <- rWishart(1,df=n-1,Sigma=diag(1,ncol=nstrat,nrow=nstrat)) / n  # sic n
  dim(ssig) <- c(nstrat,nstrat)

  # total effect
  smus <- outer(smu1,pmus - pmus[1],FUN='+')
  smps <- solve(ssig,smus)
  szetasq <- (colSums(smus * smps))
  # sub effect
  dmus <- outer(smu1[1:p],pmus - pmus[1],FUN='+')
  dmps <- solve(ssig[1:p,1:p],dmus)
  dzetasq <- (colSums(dmus * dmps))

  hejszeta <- sqrt(szetasq - dzetasq)

  foomps <- smps
  foomps[1:p,] <- foomps[1:p,] - dmps

  hejpsnra <- pmus * as.numeric(colSums(foomps) / sqrt(colSums(foomps^2)))
  hejpzeta <- pzeta/sqrt(2)
  cbind(hejpzeta,hejszeta,dzetasq,hejpsnra)
}
# do that many times.
repsim <- function(nrep,zetas,n,p) {
  foo <- future_replicate(nrep,onesim(pzeta=zetas,n,p))
  baz <- aperm(foo,c(1,3,2))
  dim(baz) <- c(nrep * length(zetas),dim(foo)[2])
  colnames(baz) <- colnames(foo)
  invisible(as.data.frame(baz))
}

# actually do it many times.
ope <- 252
zetasq <- c(1/4,1,4) / ope
zeta <- sqrt(2*zetasq)

params <- tidyr::crossing(tibble::tibble(n=round(100*2^(-1:10))),
                          tibble::tibble(p=2^(1:3))) %>%
  filter(n > 10 * p) %>%
  filter(n < 20000 * p)

# this good?
# 100K takes maybe 3 minutes?
nrep <- 100000L

plan(multiprocess)
set.seed(2356)
system.time({
hejresults <- params %>%
  group_by(n,p) %>%
    summarize(sims=list(repsim(nrep=nrep,zetas=zeta,n=n,p=p))) %>%
  ungroup() %>%
  tidyr::unnest()
})
plan(sequential)
@
<<'hejci_collect_sims',dependson=c('hejci_sims'),results='hide'>>=
typeI <- 0.05

# confidence intervals and coverage:
# this takes 10 times longer than the simulations? wtaf?
system.time({
  # wow, slow.
  qalpha <- qnorm(typeI)

  foores <- hejresults %>%
    distinct(n,hejpzeta,p) %>%
    mutate(cons = qchisq(1-typeI,df=p,ncp=n*hejpzeta*hejpzeta/4) - n*hejpzeta*hejpzeta/4) 

  cires <- hejresults %>%
    left_join(foores,by=c('hejpzeta','p','n')) %>%
    mutate(ci_new = hejszeta - cons / (n*hejszeta)) %>%
    group_by(hejpzeta,n,p) %>%
      summarize(#type1_add = mean(psnr < ci_add),
                #type1_div = mean(psnr < ci_div),
                #type1_tas = mean(psnr < ci_tas),
                type1_new = mean(hejpsnra < ci_new)) %>%
    ungroup() %>%
    mutate(zyr=signif(hejpzeta * sqrt(ope),digits=2)) %>%
    rename(`annualized SNR`=zyr) 
})
@

As in the unhedged case, we first perform simulations where the population parameter \Hejpsnrsqopt{\hejG} is known,
to assess the effects of \apxref{perfect_cov}.
In our simulations, we set $\nstrathej = \nstrat/2$, and let $\hejG$ be the first \nstrathej rows of the identity matrix.
We set $\pvmu=c \vone$ and $\pvsig=\eye$.
We perform $\Sexpr{prty(nrep)}$ simulations for different values of $\Hejpsnrsqopt{\hejG}$, $\nstrat$ and $\ssiz$,
computing \psnr[a] for the hedged portfolio, as well as \Hejssrsqopt{\hejG}.
We compute the lower \Sexpr{typeI} bound using knowledge of \Hejpsnrsqopt{\hejG} and compute the empirical type I rate
over the $\Sexpr{prty(nrep)}$ simulations, which we plot versus $\ssiz/\nstrat$ in \figref{hejci_plots}.
Again we see that the nominal type I rate is nearly achieved when $\ssiz > 100\nstrat$ or so.
% more here: this is not the end all simulation of course.

<<'hejci_plots',dependson=c('hejci_collect_sims'),fig.width=cfg_width,fig.height=cfg_height,out.width=cot_width,out.height=cot_height,fig.cap=fig_cap>>=
fig_cap <- paste0("The empirical type I rate, over ",prty(nrep)," simulations, of a one-sided confidence bound for $\\psnr_{a}$ are shown ",
                  "more tk. ")
                  #"for a nominal type I rate of $",typeI,"$. The daily returns are drawn from multivariate normal distribution with varying \\psnropt, \\ssiz, and \\nstrat. ",
                  #"Type I rates are plotted versus $\\ssiz/\\nstrat$ to indicate the requisite aspect ratio to achieve near nominal coverage. ")
									#"The confidence intervals generally fail to achieve the nominal rate except for unrealistically large values of \\ssiz. ")

# plot CIs:
library(ggplot2)
ph <- cires %>%
  tidyr::gather(key=type,value=type1,matches('^type1_')) %>%
	mutate(type=case_when(.$type=='type1_add' ~ 'difference',
												.$type=='type1_div' ~ 'product',
												.$type=='type1_tas' ~ 'tas',
												.$type=='type1_new' ~ 'SRIC',
												TRUE ~ 'bad code')) %>%
  mutate(type=factor(type,levels=c('SRIC','difference','product','tas'))) %>%
  filter(as.character(type)=='SRIC') %>%
  mutate(khej=p) %>%
  mutate(k=2*p) %>%
  mutate(xrat=n/k) %>%
  ggplot(aes(xrat,type1,color=factor(k))) +
  geom_line() + geom_point() + 
  #facet_grid(k ~ `annualized SNR`,scales='free',labeller=label_both) + 
  facet_grid(. ~ `annualized SNR`,scales='free',labeller=label_both) + 
  scale_x_log10() +
  #scale_y_sqrt() + 
  scale_y_continuous() + 
  geom_hline(yintercept=0.05,linetype=2,alpha=0.5) + 
  labs(x=expression(n/k),
       y='empirical type I rates at nominal 0.05 level',
       color=expression(k),
       shape=expression(k),
       #color='CI Bound',shape='CI Bound',
       title='Coverage of CIs on achieved SNR of the hedged Markowitz portfolio\nGaussian returns, using clairvoyance.')
print(finish_plot(ph))
rm(cires)
@
%UNFOLD

%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}%FOLDUP


%\begin{example}[Fama French Four Factors, Confidence Intervals]%FOLDUP
%\index{Fama French 4 Factor returns}
\paragraph{Fama French 4 Factor Returns}
\label{example:3400185f-3864-4011-94df-5f756d81c044}
<<'example:3400185f-3864-4011-94df-5f756d81c044',results='asis',dependson=c('aqfb_data')>>=
suppressMessages({
	library(dplyr)
	library(xts)
	library(SharpeR)
	library(aqfb.data)
})
data(mff4)
sdat <- mff4[,! colnames(mff4) %in% c("RF")]

TEO <- time(mff4)
TEO.i <- TEO[1]
TEO.f <- TEO[length(TEO)]

ssiz <- nrow(sdat)
nstrat <- ncol(sdat)
svmu <- as.vector(apply(sdat,MARGIN=2,mean,na.rm=TRUE))
svsig <- cov(sdat)
ssrsqopt <- as.numeric(svmu %*% solve(svsig,svmu))
ssropt <- sqrt(ssrsqopt)

typeI <- 0.05
#SRIC <- ssropt - (nstrat - 1) / (ssiz * ssropt)

df2 <- ssiz - nstrat
delta0 <- ((df2 - 2) / (ssiz-1)) * ssrsqopt - (nstrat/ssiz)
delta2 <- pmax(delta0,(2/(nstrat+2)) * (delta0 + (nstrat/ssiz)))
ub <- sqrt(delta2)
#ssropt <- sqrt(ssrsqopt)

cons <- qchisq(1-typeI/2,df=nstrat,ncp=ssiz*ub*ub/4) - ssiz*ub*ub/4
lo_bound <- ssropt - cons / (ssiz*ssropt)
cons <- qchisq(typeI/2,df=nstrat,ncp=ssiz*ub*ub/4) - ssiz*ub*ub/4
hi_bound <- ssropt - cons / (ssiz*ssropt)

Ffoo <- function(zval,fval,ssiz,df1,df2) {
	pf(fval,df1=df1,df2=df2,ncp=ssiz*zval^2)
}
qlim <- function(ssrsqopt,ssiz,nstrat,df1=nstrat,df2=ssiz-nstrat,lvl=0.025) {
	fval <- (ssiz/(ssiz-1)) * (df2/df1) * ssrsqopt
	ofunc <- function(z) { lvl - Ffoo(z,fval,ssiz=ssiz,df1=df1,df2=df2) }
	if (ofunc(0) > 0) { return(0) }
	zval <- uniroot(ofunc,lower=0,upper=10)$root
	return(zval)
}
qlo <- qlim(ssrsqopt,ssiz,nstrat,lvl=1-typeI/2)
qhi <- qlim(ssrsqopt,ssiz,nstrat,lvl=typeI/2)
@
We consider a portfolio constructed on the `Market', size (SMB), value (HML)
and momentum (HMD) portfolios described by Fama and French, \emph{inter alia},
with data compiled and published by Kenneth French.  \cite{Fama_French_1992,Carhart_1997,french_data_library}
The set consists of $\ssiz=\Sexpr{ssiz}\,\moto{}$ of data, from 
\Sexpr{TEO.i} through \Sexpr{TEO.f}. 
We observe $\ssrsqopt=\Sexpr{ssrsqopt}\,\moto{-1}$.
%We consider a portfolio on the returns of the Market, SMB, HML and UMD portfolios introduced in \exampleref{ff4_rets}.
From this we compute $\delta_2 = \Sexpr{delta2}\,\moto{-1}$.
Plugging in $\sqrt{\delta_2}$ for \psnropt 
we compute a two-sided $\Sexpr{100*(1-typeI)}\%$ confidence bound on \psnr[a] as 
$\ccinterval{\Sexpr{lo_bound}}{\Sexpr{hi_bound}}\,\moto{-\halff}$.
By comparison, via the connection to the \flaw{} distribution,
we compute $\Sexpr{100*(1-typeI)}\%$ confidence intervals on \psnropt as
$\ccinterval{\Sexpr{qlo}}{\Sexpr{qhi}}\,\moto{-\halff}$.
%\end{example}%UNFOLD


%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}%FOLDUP

Testing indicates the confidence bound exhibits closer to nominal
coverage than the known asymptotic bounds for reasonable \ssiz and \nstrat.
Further work should naturally focus on mitigating the effects of the
approximation $\svsig\approx\pvsig$, and finding a coverage guarantee
of the plug-in estimator. 
We also anticipate that this confidence bound procedure can be adapted
to deal with hedging constraints and conditional expectation models.

%UNFOLD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% bibliography%FOLDUP
\bibliographystyle{plainnat}
%\bibliography{SharpeR}
\bibliography{snrinf}
%UNFOLD

\end{document}
%for vim modeline: (do not edit)
% vim:fdm=marker:fmr=FOLDUP,UNFOLD:cms=%%s:syn=rnoweb:ft=rnoweb:et:nu:tw=131
